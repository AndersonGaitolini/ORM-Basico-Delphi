unit DaoIbx;

interface

uses Db, Base, Rtti, Atributos, system.SysUtils, System.Classes,
  ibx.IB, ibx.IBQuery, ibx.IBDatabase;

type
  TTransIbx = class (TTransacaoBase)
  private
    // transação para crud
    FTransaction: TIbTransaction;

  public
    constructor Create(ABanco: TIBDatabase);
    destructor Destroy; override;

    function InTransaction: Boolean; override;

    procedure StartTransaction; override;
    procedure Commit; override;
    procedure RollBack; override;

    property Transaction: TIBTransaction read FTransaction write FTransaction;
  end;

  TConexaoIbx = class(TConexaoBase)
  private
    // conexao com o banco de dados
    FDatabase: TIBDatabase;
    // transação
    FTransIbx: TTransIbx;
    // transação para consultas
    FTransQuery: TIBTransaction;
  public
    constructor Create();
    destructor Destroy; override;

    function Conectado: Boolean; override;

    procedure Conecta; override;

    property Database: TIBDatabase read FDatabase write FDatabase;
    property Transaction: TTransIbx read FTransIbx write FTransIbx;
    property TransQuery: TIBTransaction read FTransQuery write FTransQuery;
  end;

  TDaoIbx = class(TDaoBase)
  private
    FConexao: TConexaoIbx;
  protected
    // métodos responsáveis por setar os parâmetros
    procedure QryParamInteger(ARecParams: TRecParams); override;
    procedure QryParamString(ARecParams: TRecParams); override;
    procedure QryParamDate(ARecParams: TRecParams); override;
    procedure QryParamCurrency(ARecParams: TRecParams); override;
    procedure QryParamVariant(ARecParams: TRecParams); override;

    //métodos para setar os variados tipos de campos
    procedure SetaCamposInteger(ARecParams: TRecParams); override;
    procedure SetaCamposString(ARecParams: TRecParams); override;
    procedure SetaCamposDate(ARecParams: TRecParams); override;
    procedure SetaCamposCurrency(ARecParams: TRecParams); override;

    function ExecutaQuery: Integer; override;
  public
    //query para execução dos comandos crud
    Qry: TIBQuery;

    constructor Create(AConexao: TConexaoIbx);
    destructor Destroy; override;

    //dataset para as consultas
    function ConsultaSql(ASql: string): TDataSet; override;

    //pega campo autoincremento
    function GetAutoIncremento (ATabela, ACampo: string): integer; override;

    //crud
    function Inserir(ATabela: TTabela): Integer; override;
    function Salvar(ATabela: TTabela): Integer;  override;
    function Excluir(ATabela: TTabela): Integer; override;
    function Buscar(ATabela:TTabela): Integer; override;
  end;

implementation

uses Vcl.forms, dialogs, System.TypInfo;

{ TTransIbx }

constructor TTransIbx.Create(ABanco: TIBDatabase);
begin
  inherited Create;

  FTransaction := TIBTransaction.Create(Application);
  with FTransaction do
  begin
    DefaultDatabase := ABanco;
    Params.Add('read_committed');
    Params.Add('rec_version');
    Params.Add('nowait');
  end;
end;

destructor TTransIbx.Destroy;
begin
  inherited;
end;

function TTransIbx.InTransaction: Boolean;
begin
  Result := FTransaction.InTransaction;
end;

procedure TTransIbx.StartTransaction;
begin
  if not FTransaction.InTransaction then
    FTransaction.StartTransaction;
end;

procedure TTransIbx.RollBack;
begin
  FTransaction.RollBack;
end;

procedure TTransIbx.Commit;
begin
  FTransaction.Commit;
end;

constructor TConexaoIbx.Create();
begin
  inherited Create;
  FDatabase := TIBDatabase.Create(Application);
  FTransIbx := TTransIbx.Create(FDatabase);
end;

destructor TConexaoIbx.Destroy;
begin
  FTransIbx.Free;
  inherited;
end;

function TConexaoIbx.Conectado: Boolean;
begin
  Result := Database.Connected;
end;

procedure TConexaoIbx.Conecta;
var
  ASenha, AUsuario: string;
begin
  inherited;
  if Usuario=EmptyStr then
    AUsuario := 'SYSDBA'
  else
    AUsuario := Usuario;

  if Senha = EmptyStr then
    ASenha := '02025626'
  else
    ASenha := Senha;

  with Database do
  begin
    DatabaseName := LocalBD;
    Params.Clear;
    Params.Add('user_name=' + AUsuario);
    Params.Add('password=' + ASenha);
    LoginPrompt := false;
    Connected := True;
  end;
end;

{ TDaoIbx }

constructor TDaoIbx.Create(AConexao: TConexaoIbx);
var
  MeuDataSet: TIBQuery;
begin
  inherited Create;

  FConexao := AConexao;

  with AConexao do
  begin
    //configurações iniciais da transacao para consultas
    FTransQuery := TIBTransaction.Create(Application);
    with TransQuery do
    begin
      DefaultDatabase := Database;
      Params.Add('read_committed');
      Params.Add('rec_version');
      Params.Add('nowait');
    end;

    Database.DefaultTransaction := TransQuery;

    //configurações iniciais da transacao para crud
    FTransIbx := TTransIbx.Create(Database);
  end;

  Qry := TIBQuery.Create(Application);
  Qry.DataBase := FConexao.Database;
  Qry.Transaction := FConexao.Transaction.Transaction;

  MeuDataSet          := TIBQuery.Create(Application);
  MeuDataSet.DataBase := FConexao.Database;

  DataSet := MeuDataSet;
end;

destructor TDaoIbx.Destroy;
begin
  inherited;
end;

procedure TDaoIbx.QryParamCurrency(ARecParams: TRecParams);
begin
  inherited;
  with ARecParams do
  begin
    TIBQuery(Qry).ParamByName(Campo).AsCurrency := Prop.GetValue(Tabela).AsCurrency;
  end;
end;

procedure TDaoIbx.QryParamDate(ARecParams: TRecParams);
begin
  inherited;
  with ARecParams do
  begin
    TIBQuery(Qry).ParamByName(Campo).AsDateTime := Prop.GetValue(Tabela).AsType<TDateTime>;
  end;
end;

procedure TDaoIbx.QryParamInteger(ARecParams: TRecParams);
begin
  inherited;
  with ARecParams do
  begin
    TIBQuery(Qry).ParamByName(Campo).AsInteger := Prop.GetValue(Tabela).AsInteger;
  end;
end;

procedure TDaoIbx.QryParamString(ARecParams: TRecParams);
begin
  inherited;
  with ARecParams do
  begin
    TIBQuery(Qry).ParamByName(Campo).AsString := Prop.GetValue(Tabela).AsString;
  end;
end;

procedure TDaoIbx.QryParamVariant(ARecParams: TRecParams);
begin
  inherited;
  with ARecParams do
  begin
    TIBQuery(Qry).ParamByName(Campo).Value := Prop.GetValue(Tabela).AsVariant;
  end;
end;

procedure TDaoIbx.SetaCamposCurrency(ARecParams: TRecParams);
begin
  inherited;
  with ARecParams do
  begin
    Prop.SetValue(Tabela, TIBQuery(Qry).FieldByName(Campo).AsCurrency);
  end;
end;

procedure TDaoIbx.SetaCamposDate(ARecParams: TRecParams);
begin
  inherited;
  with ARecParams do
  begin
    Prop.SetValue(Tabela, TIBQuery(Qry).FieldByName(Campo).AsDateTime);
  end;
end;

procedure TDaoIbx.SetaCamposInteger(ARecParams: TRecParams);
begin
  inherited;
  with ARecParams do
  begin
    Prop.SetValue(Tabela, TIBQuery(Qry).FieldByName(Campo).AsInteger);
  end;
end;

procedure TDaoIbx.SetaCamposString(ARecParams: TRecParams);
begin
  inherited;
  with ARecParams do
  begin
    Prop.SetValue(Tabela, TIBQuery(Qry).FieldByName(Campo).AsString);
  end;
end;

function TDaoIbx.ConsultaSql(ASql: string): TDataSet;
var
  AQry: TIBQuery;
begin
  AQry := TIBQuery.Create(Application);
  with AQry do
  begin
    DataBase := FConexao.Database;
    sql.Clear;
    sql.Add(ASql);
    Open;
  end;
  Result := AQry;
end;

function TDaoIbx.GetAutoIncremento(ATabela, ACampo: string): integer;
var
  AQry: TIBQuery;
begin
  AQry := TIBQuery.Create(Application);
  with AQry do
  begin
    DataBase := FConexao.Database;
    sql.Clear;
    sql.Add('select max('+ACampo+') from ' + ATabela);
    Open;
    Result := fields[0].AsInteger + 1;
  end;
end;

function TDaoIbx.ExecutaQuery: Integer;
begin
  with Qry do
  begin
    Prepare();
    ExecSQL;
    Result := RowsAffected;
  end;
end;

function TDaoIbx.Excluir(ATabela: TTabela): Integer;
var
  Comando: TFuncReflexao;
begin
  //crio uma variável do tipo TFuncReflexao - um método anônimo
  Comando := function(ACampos: TCamposAnoni): Integer
  var
    Campo: string;
    PropRtti: TRttiProperty;
  begin
    Qry.close;
    Qry.SQL.Clear;
    Qry.SQL.Text := GerarSqlDelete(ATabela);
    //percorrer todos os campos da chave primária
    for Campo in PegaPks(ATabela) do
    begin
      // setando os parâmetros
      for PropRtti in ACampos.TipoRtti.GetProperties do
        if CompareText(PropRtti.Name, Campo) = 0 then
          begin
            ConfiguraParametro(PropRtti, Campo, ATabela, Qry);
          end;
    end;
    Result := ExecutaQuery;
  end;

  //reflection da tabela e execução da query preparada acima.
  Result := ReflexaoSQL(ATabela, Comando);
end;

function TDaoIbx.Inserir(ATabela: TTabela): Integer;
var
  Comando: TFuncReflexao;
begin
  Result := 0;

  if not ValidaTabela(ATabela) then
    exit;

  Comando := function(ACampos: TCamposAnoni): Integer
  var
    Campo: string;
    PropRtti: TRttiProperty;
  begin
    with Qry do
    begin
      close;
      sql.Clear;
      SQL.Text := GerarSqlInsert(ATabela, ACampos.TipoRtti);
      //valor dos parâmetros
      for PropRtti in ACampos.TipoRtti.GetProperties do
      begin
        Campo := PropRtti.Name;
        ConfiguraParametro(PropRtti, Campo, ATabela, Qry);
      end;
    end;
    Result := ExecutaQuery;
  end;

  //reflection da tabela e execução da query preparada acima.
  Result := ReflexaoSQL(ATabela, Comando);
end;

function TDaoIbx.Salvar(ATabela: TTabela): Integer;
var
  Comando: TFuncReflexao;
begin
  Result := 0;

  if not ValidaTabela(ATabela) then exit;

  Comando := function(ACampos: TCamposAnoni): Integer
  var
    Campo: string;
    PropRtti: TRttiProperty;
  begin
    with Qry do
    begin
      close;
      sql.Clear;
      sql.Text := GerarSqlUpdate(ATabela, Acampos.TipoRtti);
      //valor dos parâmetros
      for PropRtti in ACampos.TipoRtti.GetProperties do
      begin
        Campo := PropRtti.Name;
        ConfiguraParametro(PropRtti, Campo, ATabela, Qry);
      end;
    end;
    Result := ExecutaQuery;
  end;

  //reflection da tabela e execução da query preparada acima.
  Result := ReflexaoSQL(ATabela, Comando);
end;

function TDaoIbx.Buscar(ATabela: TTabela): Integer;
var
  Comando: TFuncReflexao;
  Dados: TIBQuery;
begin
  Dados := TIBQuery.Create(nil);
  try
    //crio uma variável do tipo TFuncReflexao - um método anônimo
    Comando := function(ACampos: TCamposAnoni): Integer
    var
      Campo: string;
      PropRtti: TRttiProperty;
    begin
      with Dados do
      begin
        Database := FConexao.Database;
        sql.Text := GerarSqlSelect(ATabela);

        for Campo in ACampos.PKs do
        begin
          // setando os parâmetros
          for PropRtti in ACampos.TipoRtti.GetProperties do
            if CompareText(PropRtti.Name, Campo) = 0 then
              begin
                ConfiguraParametro(PropRtti, Campo, ATabela, Dados);
              end;
        end;
        Open;
        Result := RecordCount;
        if Result > 0 then
        begin
          for PropRtti in ACampos.TipoRtti.GetProperties do
          begin
            Campo := PropRtti.Name;
            SetaDadosTabela(PropRtti, Campo, ATabela, Dados);
          end;
        end;
      end;
    end;

    //reflection da tabela e abertura da query preparada acima.
    Result := ReflexaoSQL(ATabela, Comando);
  finally
    Dados.Free;
  end;
end;

end.
