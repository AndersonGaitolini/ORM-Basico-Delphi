unit Atributos;

interface

uses
  Base, Rtti, System.Classes;

type
  // TTipoCampo = (tcNormal, tcPK, tcRequerido);

  TCamposAnoni = record
    NomeTabela: string;
    Sep: string;
    PKs: TResultArray;
    TipoRtti: TRttiType;
  end;

  TFuncReflexao = reference to function(ACampos: TCamposAnoni): Integer;

  TNomeTabela = class(TCustomAttribute)
  private
    FNomeTabela: string;
  public
    constructor Create(ANomeTabela: string);
    property NomeTabela: string read FNomeTabela write FNomeTabela;
  end;

  /// <summary>
  /// Atributos de Chave Primaria e Relacionamentos
  /// </summary>

  CampoPK = class(TCustomAttribute)
  end;

  /// <summary>
  /// Atributos de Validação
  /// </summary>

  BaseValidacao = class(TCustomAttribute)
  private
    FMensagemErro: string;
    procedure SetMessagemErro(const Value: string);
  public
    property MessagemErro: string read FMensagemErro write SetMessagemErro;
  end;

  BaseValidaString = class(BaseValidacao)
  public
    function Validar(Value: string): Boolean; virtual; abstract;
  end;

  ValidaStringVazia = class(BaseValidaString)
  public
    constructor Create(const MensagemErro: string);
    function Validar(Value: string): Boolean; override;
  end;

  BaseValidaInteger = class(BaseValidacao)
  public
    function Validar(Value: Integer): Boolean; virtual; abstract;
  end;

  ValidaIntegerMinimo = class(BaseValidaInteger)
  private
    FValorMinimo: Integer;
  public
    constructor Create(ValorMinimo: Integer; const MensagemErro: string);
    function Validar(Value: Integer): Boolean; override;
  end;

  ValidaIntegerMaximo = class(BaseValidaInteger)
  private
    FValorMaximo: Integer;
  public
    constructor Create(ValorMaximo: Integer; const MensagemErro: string);
    function Validar(Value: Integer): Boolean; override;
  end;

  // Reflection para os comandos Sql
function ReflexaoSQL(ATabela: TTabela; AnoniComando: TFuncReflexao): Integer;

function PegaNomeTab(ATabela: TTabela): string;
function PegaPks(ATabela: TTabela): TResultArray;
function ValidaTabela(ATabela: TTabela): Boolean;
procedure SetarPropriedade(AObj: TObject; AProp: string; AValor: Variant);

implementation

uses
  System.TypInfo, System.SysUtils, Forms, Winapi.Windows, System.Variants;

procedure SetarPropriedade(AObj: TObject; AProp: string; AValor: Variant);
var
  Contexto: TRttiContext;
  TipoRtti: TRttiType;
  PropRtti: TRttiProperty;
begin
  Contexto := TRttiContext.Create;
  try
    TipoRtti := Contexto.GetType(AObj.ClassType);
    for PropRtti in TipoRtti.GetProperties do
    begin
      if CompareText(PropRtti.Name, AProp) = 0 then
      begin
        PropRtti.SetValue(AObj, System.Variants.VarToStr(AValor));
      end;
    end;
  finally
    Contexto.free;
  end;
end;

function ReflexaoSQL(ATabela: TTabela; AnoniComando: TFuncReflexao): Integer;
var
  ACampos: TCamposAnoni;
  Contexto: TRttiContext;
begin
  ACampos.NomeTabela := PegaNomeTab(ATabela);

  if ACampos.NomeTabela = EmptyStr then
    raise Exception.Create('Informe o Atributo NomeTabela na classe ' +
      ATabela.ClassName);

  ACampos.PKs := PegaPks(ATabela);

  if Length(ACampos.PKs) = 0 then
    raise Exception.Create('Informe campos da chave primária na classe ' +
      ATabela.ClassName);

  Contexto := TRttiContext.Create;
  try
    ACampos.TipoRtti := Contexto.GetType(ATabela.ClassType);

    // executamos os comandos Sql através do método anônimo
    ACampos.Sep := '';
    Result := AnoniComando(ACampos);

  finally
    Contexto.free;
  end;
end;

function PegaNomeTab(ATabela: TTabela): string;
var
  Contexto: TRttiContext;
  TipoRtti: TRttiType;
  AtribRtti: TCustomAttribute;
begin
  Contexto := TRttiContext.Create;
  TipoRtti := Contexto.GetType(ATabela.ClassType);
  try
    for AtribRtti in TipoRtti.GetAttributes do
      if AtribRtti Is TNomeTabela then
      begin
        Result := (AtribRtti as TNomeTabela).NomeTabela;
        Break;
      end;
  finally
    Contexto.free;
  end;
end;

function ValidaTabela(ATabela: TTabela): Boolean;
var
  Contexto: TRttiContext;
  TipoRtti: TRttiType;
  PropRtti: TRttiProperty;
  AtribRtti: TCustomAttribute;
  ListaErros: TStrings;
begin
  Result := True;

  if not Assigned(ATabela) then
    raise Exception.Create('Tabela não foi passada no parâmetro!');

  if not Assigned(ListaErros) then
    raise Exception.Create('Lista de erros não inicializada!');

  ListaErros := TStringList.Create;
  try
    Contexto := TRttiContext.Create;
    try
      TipoRtti := Contexto.GetType(ATabela.ClassType);
      for PropRtti in TipoRtti.GetProperties do
      begin
        for AtribRtti in PropRtti.GetAttributes do
        begin
          if AtribRtti is BaseValidaInteger then
          begin
            if not BaseValidaInteger(AtribRtti).Validar(PropRtti.GetValue(ATabela).AsInteger) then
             ListaErros.Add(BaseValidacao(AtribRtti).MessagemErro);
          end;

          if AtribRtti is BaseValidaString then
          begin
            if not BaseValidaString(AtribRtti).Validar(PropRtti.GetValue(ATabela).AsString) then
             ListaErros.Add(BaseValidacao(AtribRtti).MessagemErro);
          end;
        end;
      end;
    finally
      Contexto.free;
    end;

    if ListaErros.Count > 0 then
    begin
      Result := False;
      Application.MessageBox(PChar(ListaErros.Text), 'Erros Encontrados', MB_OK+MB_ICONERROR);
    end;
  finally
    ListaErros.Free;
  end;
end;

function PegaPks(ATabela: TTabela): TResultArray;
var
  Contexto: TRttiContext;
  TipoRtti: TRttiType;
  PropRtti: TRttiProperty;
  AtribRtti: TCustomAttribute;
  i: Integer;
begin
  Contexto := TRttiContext.Create;
  try
    TipoRtti := Contexto.GetType(ATabela.ClassType);
    i := 0;
    for PropRtti in TipoRtti.GetProperties do
      for AtribRtti in PropRtti.GetAttributes do
        if AtribRtti Is CampoPK then
        begin
          SetLength(Result, i + 1);
          Result[i] := PropRtti.Name;
          inc(i);
        end;
  finally
    Contexto.free;
  end;
end;

{ TNomeTabela }

constructor TNomeTabela.Create(ANomeTabela: string);
begin
  FNomeTabela := ANomeTabela;
end;

{ TBaseValidacao }

procedure BaseValidacao.SetMessagemErro(const Value: string);
begin
  FMensagemErro := Value;
end;

{ TValidaIntegerMinimo }

constructor ValidaIntegerMinimo.Create(ValorMinimo: Integer;
  const MensagemErro: string);
begin
  FValorMinimo := ValorMinimo;
  FMensagemErro := MensagemErro;
end;

function ValidaIntegerMinimo.Validar(Value: Integer): Boolean;
begin
  Result := Value >= FValorMinimo;
end;

{ TValidaIntegerMaximo }

constructor ValidaIntegerMaximo.Create(ValorMaximo: Integer;
  const MensagemErro: string);
begin
  FValorMaximo := ValorMaximo;
  FMensagemErro := MensagemErro;
end;

function ValidaIntegerMaximo.Validar(Value: Integer): Boolean;
begin
  Result := Value <= FValorMaximo;
end;

{ TValidaStringNaoNulo }

constructor ValidaStringVazia.Create(const MensagemErro: string);
begin
  FMensagemErro := MensagemErro;
end;

function ValidaStringVazia.Validar(Value: string): Boolean;
begin
  Result := not(Value = EmptyStr);
end;

end.
